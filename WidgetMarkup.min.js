////////////////////////////////////////////////////////////////////////////////////
// {</>} WidgetMarkup - Simple implementation of markup for Scriptable iOS widgets.
////////////////////////////////////////////////////////////////////////////////////
// Version 0.20210820a
const WidgetMarkup=(()=>{function t(t){if(t&&t.constructor&&t.constructor.toString){let e=t.constructor.toString().match(/function\s*(\w+)/);if(e&&2==e.length)return e[1]}}function e(e,n){return Object.keys(n).forEach(r=>{if(-1!==r.indexOf("*")){if(!((r=r.replace("*",""))in e))throw new Error(`Method "${r}()" is not applicable to instance of ${t(e)}`);Array.isArray(n["*"+r])?e[r](...n["*"+r]):e[r](n[r])}else{if(!(r in e))throw new Error(`Property "${r}" is not applicable to instance of ${t(e)}`);e[r]=n[r]}}),e}function n(t=[],e="styles"){let n={};return t.forEach(t=>{t.name.toLowerCase()===e.toLowerCase()&&(n=void 0!==r[t.value]?r[t.value]:t.value)}),n}const r={};function a(t,e){let n="";return t.forEach((t,a)=>{if(e[a])if(Array.isArray(e[a])&&(e[a]=e[a].join("")),"string"==typeof e[a])n+=t+e[a];else{let o="$$["+UUID.string()+Math.floor(20*Math.random())+"]";r[o]=e[a],n+=t+o}else n+=t}),n}return{widgetMarkup:async function(t,...o){let i=a(t,o);const s=(await async function(t){const e=new WebView;await e.loadHTML("<html></html>");const n=`\n        var getAttributes = function (attributes) {\n            return Array.prototype.map.call(attributes, function (attribute) {\n                return {\n                    name: attribute.name,\n                    value: attribute.value\n                };\n            });\n        };\n        \n        var createDOMMap = function (element) {\n            return Array.prototype.map.call(element.childNodes, (function (node) {\n                if (node.nodeType !== 3 && node.nodeType !== 8) {\n                    var details = {\n                        tag: node.tagName.toLowerCase(),\n                        textContent: node.textContent,\n                        attributes: node.nodeType !== 1 ? [] : getAttributes(node.attributes)\n                    };\n                    details.children = createDOMMap(node);\n                    return details;\n                }\n                return null;\n            })).filter((e) => e !== null);\n        };\n        \n        function getDom() {\n            let htmlStr = '${t=`<tabom>${t=t.replace(/(\r\n|\n|\r)/gm,"")}</tabom>`}';\n            const dom = new DOMParser();\n            let doc = dom.parseFromString(htmlStr, 'application/xml');\n            return JSON.stringify(createDOMMap(doc.documentElement));\n        }\n        try {\n            completion(getDom());\n        }\n        catch (err) {\n            completion([{\n                tag: 'error',\n                textContent: err.message\n            }]);\n        }    \n      `;let r=await e.evaluateJavaScript(n,!0);const a=JSON.parse(r);if(a.length&&-1!==a[0].tag.toLocaleLowerCase().indexOf("error"))throw new Error(a[0].textContent);return a}(i))[0];if(void 0===s)throw new Error("WidgetMarkup requires that the <widget> element be the parent element of your widget.");const l=s.children,c=new ListWidget;return e(c,n(s.attributes,"styles")),function t(a,o){return o.forEach(o=>{if("text"===o.tag){const t=/(\$\$\[.+\])/gi;t.test(o.textContent)&&(o.textContent=o.textContent.replace(t,(t,e)=>r[e].toString())),e(a.addText(o.textContent),n(o.attributes,"styles"))}else if("spacer"===o.tag){let t=parseInt(n(o.attributes,"value"),10);t<1||isNaN(t)?a.addSpacer():a.addSpacer(t)}else if("image"===o.tag)e(a.addImage(n(o.attributes,"src")),n(o.attributes,"styles"));else if("date"===o.tag)e(a.addDate(n(o.attributes,"value")),n(o.attributes,"styles"));else if("stack"===o.tag){let r=a.addStack();e(r,n(o.attributes,"styles")),t(r,o.children)}}),a}(c,l),c},concatMarkup:function(t,...e){return a(t,e)}}})();
